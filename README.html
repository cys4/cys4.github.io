<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <script src="http://math.etsu.edu/LaTeXMathML/LaTeXMathML.js" type="text/javascript"></script>
</head>
<body>
<h1 id="mlia-ch.-6-support-vector-machines">MLiA Ch. 6: support vector machines</h1>
<h2 id="개요">개요</h2>
<ul>
<li>Supervised learning, (deep learning에 상대적으로) shallow learning의 대표적인 방법</li>
<li>장: generalization 성능 좋다</li>
<li>단: 기본적인 SVM은 이진 &amp; 선형 분류만 지원 (여러 변형 통해 multinomial &amp; 비선형 분류도 가능)</li>
</ul>
<script src="http://math.etsu.edu/LaTeXMathML/LaTeXMathML.js" type="text/javascript"></script>
<p><span class="LaTeX"><span class="LaTeX">$w\cdot x-b=0$</span></span></p>
<h2 id="training">Training</h2>
<ul>
<li>주어진 training data에 대해 margin을 최대화하는 classifier을 구함</li>
<li>Hyperplane: 분류 경계 형성하는 (n-1) 차원의 선형 이진 classifier( <span class="LaTeX">$w\cdot x-b=0$</span> )</li>
<li>Support vector: hyperplane에 가장 가까운 점들( <span class="LaTeX">$w\cdot x-b=1$</span>, <span class="LaTeX">$w\cdot x-b=-1$</span> )</li>
<li>Margin: support vector와 hyperplane 사이의 거리 ( <span class="LaTeX">$\frac{2}{||w||}$</span> )</li>
<li>다음의 constrained optimization 문제로 귀결됨</li>
<li>Lagrange multiplier 이용 &gt; &quot;Minimize <span class="LaTeX">$\|\vec{w}\|$</span> subject to <span class="LaTeX">$y_i(\vec{w}\cdot\vec{x_i} - b) \ge 1$</span>, for <span class="LaTeX">$i = 1,\,\ldots,\,n$</span>&quot;</li>
</ul>
<div class="figure">
<img src="Svm_max_sep_hyperplane_with_margin.png" />

</div>
<!-- ![Support vector와 margin](https://upload.wikimedia.org/wikipedia/commons/2/2a/Svm_max_sep_hyperplane_with_margin.png) -->
<head>
<pre><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
&lt;meta http-equiv=&quot;Content-Style-Type&quot; content=&quot;text/css&quot; /&gt;
&lt;meta name=&quot;generator&quot; content=&quot;pandoc&quot; /&gt;
&lt;title&gt;&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt;code{white-space: pre;}&lt;/style&gt;
&lt;style type=&quot;text/css&quot;&gt;</code></pre>
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode { margin: 0; padding: 0; vertical-align: baseline; border: none; } table.sourceCode { width: 100%; line-height: 100%; } td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; } td.sourceCode { padding-left: 5px; } code &gt; span.kw { color: #007020; font-weight: bold; } code &gt; span.dt { color: #902000; } code &gt; span.dv { color: #40a070; } code &gt; span.bn { color: #40a070; } code &gt; span.fl { color: #40a070; } code &gt; span.ch { color: #4070a0; } code &gt; span.st { color: #4070a0; } code &gt; span.co { color: #60a0b0; font-style: italic; } code &gt; span.ot { color: #007020; } code &gt; span.al { color: #ff0000; font-weight: bold; } code &gt; span.fu { color: #06287e; } code &gt; span.er { color: #ff0000; font-weight: bold; }
</style>
<pre><code>&lt;script src=&quot;http://math.etsu.edu/LaTeXMathML/LaTeXMathML.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre>
</head>
<h3 id="참고">참고</h3>
<ul>
<li>https://en.wikipedia.org/wiki/Support_vector_machine</li>
<li>https://ko.wikipedia.org/wiki/서포트_벡터_머신</li>
<li>http://cs229.stanford.edu/notes/cs229-notes3.pdf</li>
<li>Christopher M. Bishop, Pattern Recognition and Machine Learning (Springer, 2006)</li>
</ul>
<h2 id="sequential-minimal-optimization-smo-algorithm">Sequential minimal optimization ( SMO ) algorithm</h2>
<ul>
<li>SVM 구현 알고리즘</li>
</ul>
<div class="figure">
<img src="https://upload.wikimedia.org/math/a/7/4/a745d413de81c293a28dde584c6717df.png" />

</div>
<p><span class="LaTeX">$\vec{w}\cdot\vec{x} - b=-1.\,$</span></p>
<p><span class="LaTeX">$$ R_{\mu \nu} - {1 \over 2}g_{\mu \nu}\,R + g_{\mu \nu} \Lambda
= {8 \pi G \over c^4} T_{\mu \nu} $$</span></p>
<blockquote>
<p>Quote</p>
<blockquote>
<p>Nested quote</p>
</blockquote>
<p>Out of the nest</p>
</blockquote>
<pre class="sourceCode python"><code class="sourceCode python"><span class="ch">from</span> numpy <span class="ch">import</span> *
<span class="ch">from</span> time <span class="ch">import</span> sleep

<span class="kw">def</span> loadDataSet(fileName):
    dataMat = []; labelMat = []
    fr = <span class="dt">open</span>(fileName)
    <span class="kw">for</span> line in fr.readlines():
        lineArr = line.strip().split(<span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>)
        dataMat.append([<span class="dt">float</span>(lineArr[<span class="dv">0</span>]), <span class="dt">float</span>(lineArr[<span class="dv">1</span>])])
        labelMat.append(<span class="dt">float</span>(lineArr[<span class="dv">2</span>]))
    <span class="kw">return</span> dataMat,labelMat
    <span class="dt">int</span> a;  </code></pre>
<table>
<thead>
<tr class="header">
<th align="left">표</th>
<th align="left">항목 1</th>
<th align="left">항목 2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">a</td>
<td align="left">b</td>
<td align="left">c</td>
</tr>
<tr class="even">
<td align="left">가</td>
<td align="left">나</td>
<td align="left">다</td>
</tr>
</tbody>
</table>
<pre class="sourceCode python"><code class="sourceCode python"><span class="co">&#39;&#39;&#39;</span>
<span class="co">Created on Nov 4, 2010</span>
<span class="co">Chapter 5 source file for Machine Learing in Action</span>
<span class="co">@author: Peter</span>
<span class="co">&#39;&#39;&#39;</span>
<span class="ch">from</span> numpy <span class="ch">import</span> *
<span class="ch">from</span> time <span class="ch">import</span> sleep

<span class="kw">def</span> loadDataSet(fileName):
    dataMat = []; labelMat = []
    fr = <span class="dt">open</span>(fileName)
    <span class="kw">for</span> line in fr.readlines():
        lineArr = line.strip().split(<span class="st">&#39;</span><span class="ch">\t</span><span class="st">&#39;</span>)
        dataMat.append([<span class="dt">float</span>(lineArr[<span class="dv">0</span>]), <span class="dt">float</span>(lineArr[<span class="dv">1</span>])])
        labelMat.append(<span class="dt">float</span>(lineArr[<span class="dv">2</span>]))
    <span class="kw">return</span> dataMat,labelMat

<span class="kw">def</span> selectJrand(i,m):
    j=i <span class="co">#we want to select any J not equal to i</span>
    <span class="kw">while</span> (j==i):
        j = <span class="dt">int</span>(random.uniform(<span class="dv">0</span>,m))
    <span class="kw">return</span> j

<span class="kw">def</span> clipAlpha(aj,H,L):
    <span class="kw">if</span> aj &gt; H:
        aj = H
    <span class="kw">if</span> L &gt; aj:
        aj = L
    <span class="kw">return</span> aj

<span class="kw">def</span> smoSimple(dataMatIn, classLabels, C, toler, maxIter):
    dataMatrix = mat(dataMatIn); labelMat = mat(classLabels).transpose()
    b = <span class="dv">0</span>; m,n = shape(dataMatrix)
    alphas = mat(zeros((m,<span class="dv">1</span>)))
    <span class="dt">iter</span> = <span class="dv">0</span>
    <span class="kw">while</span> (<span class="dt">iter</span> &lt; maxIter):
        alphaPairsChanged = <span class="dv">0</span>
        <span class="kw">for</span> i in <span class="dt">range</span>(m):
            fXi = <span class="dt">float</span>(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[i,:].T)) + b
            Ei = fXi - <span class="dt">float</span>(labelMat[i])<span class="co">#if checks if an example violates KKT conditions</span>
            <span class="kw">if</span> ((labelMat[i]*Ei &lt; -toler) and (alphas[i] &lt; C)) or ((labelMat[i]*Ei &gt; toler) and (alphas[i] &gt; <span class="dv">0</span>)):
                j = selectJrand(i,m)
                fXj = <span class="dt">float</span>(multiply(alphas,labelMat).T*(dataMatrix*dataMatrix[j,:].T)) + b
                Ej = fXj - <span class="dt">float</span>(labelMat[j])
                alphaIold = alphas[i].copy(); alphaJold = alphas[j].copy();
                <span class="kw">if</span> (labelMat[i] != labelMat[j]):
                    L = <span class="dt">max</span>(<span class="dv">0</span>, alphas[j] - alphas[i])
                    H = <span class="dt">min</span>(C, C + alphas[j] - alphas[i])
                <span class="kw">else</span>:
                    L = <span class="dt">max</span>(<span class="dv">0</span>, alphas[j] + alphas[i] - C)
                    H = <span class="dt">min</span>(C, alphas[j] + alphas[i])
                <span class="kw">if</span> L==H: <span class="dt">print</span> <span class="st">&quot;L==H&quot;</span>; <span class="kw">continue</span>
                eta = <span class="fl">2.0</span> * dataMatrix[i,:]*dataMatrix[j,:].T - dataMatrix[i,:]*dataMatrix[i,:].T - dataMatrix[j,:]*dataMatrix[j,:].T
                <span class="kw">if</span> eta &gt;= <span class="dv">0</span>: <span class="dt">print</span> <span class="st">&quot;eta&gt;=0&quot;</span>; <span class="kw">continue</span>
                alphas[j] -= labelMat[j]*(Ei - Ej)/eta
                alphas[j] = clipAlpha(alphas[j],H,L)
                <span class="kw">if</span> (<span class="dt">abs</span>(alphas[j] - alphaJold) &lt; <span class="fl">0.00001</span>): <span class="dt">print</span> <span class="st">&quot;j not moving enough&quot;</span>; <span class="kw">continue</span>
                alphas[i] += labelMat[j]*labelMat[i]*(alphaJold - alphas[j])<span class="co">#update i by the same amount as j</span>
                                                                        <span class="co">#the update is in the oppostie direction</span>
                b1 = b - Ei- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[i,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[i,:]*dataMatrix[j,:].T
                b2 = b - Ej- labelMat[i]*(alphas[i]-alphaIold)*dataMatrix[i,:]*dataMatrix[j,:].T - labelMat[j]*(alphas[j]-alphaJold)*dataMatrix[j,:]*dataMatrix[j,:].T
                <span class="kw">if</span> (<span class="dv">0</span> &lt; alphas[i]) and (C &gt; alphas[i]): b = b1
                <span class="kw">elif</span> (<span class="dv">0</span> &lt; alphas[j]) and (C &gt; alphas[j]): b = b2
                <span class="kw">else</span>: b = (b1 + b2)/<span class="fl">2.0</span>
                alphaPairsChanged += <span class="dv">1</span>
                <span class="dt">print</span> <span class="st">&quot;iter: </span><span class="ot">%d</span><span class="st"> i:</span><span class="ot">%d</span><span class="st">, pairs changed </span><span class="ot">%d</span><span class="st">&quot;</span> % (<span class="dt">iter</span>,i,alphaPairsChanged)
        <span class="kw">if</span> (alphaPairsChanged == <span class="dv">0</span>): <span class="dt">iter</span> += <span class="dv">1</span>
        <span class="kw">else</span>: <span class="dt">iter</span> = <span class="dv">0</span>
        <span class="dt">print</span> <span class="st">&quot;iteration number: </span><span class="ot">%d</span><span class="st">&quot;</span> % <span class="dt">iter</span>
    <span class="kw">return</span> b,alphas

<span class="kw">def</span> kernelTrans(X, A, kTup): <span class="co">#calc the kernel or transform data to a higher dimensional space</span>
    m,n = shape(X)
    K = mat(zeros((m,<span class="dv">1</span>)))
    <span class="kw">if</span> kTup[<span class="dv">0</span>]==<span class="st">&#39;lin&#39;</span>: K = X * A.T   <span class="co">#linear kernel</span>
    <span class="kw">elif</span> kTup[<span class="dv">0</span>]==<span class="st">&#39;rbf&#39;</span>:
        <span class="kw">for</span> j in <span class="dt">range</span>(m):
            deltaRow = X[j,:] - A
            K[j] = deltaRow*deltaRow.T
        K = exp(K/(-<span class="dv">1</span>*kTup[<span class="dv">1</span>]**<span class="dv">2</span>)) <span class="co">#divide in NumPy is element-wise not matrix like Matlab</span>
    <span class="kw">else</span>: <span class="kw">raise</span> <span class="ot">NameError</span>(<span class="st">&#39;Houston We Have a Problem -- \</span>
<span class="st">    That Kernel is not recognized&#39;</span>)
    <span class="kw">return</span> K

<span class="kw">class</span> optStruct:
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>,dataMatIn, classLabels, C, toler, kTup):  <span class="co"># Initialize the structure with the parameters</span>
        <span class="ot">self</span>.X = dataMatIn
        <span class="ot">self</span>.labelMat = classLabels
        <span class="ot">self</span>.C = C
        <span class="ot">self</span>.tol = toler
        <span class="ot">self</span>.m = shape(dataMatIn)[<span class="dv">0</span>]
        <span class="ot">self</span>.alphas = mat(zeros((<span class="ot">self</span>.m,<span class="dv">1</span>)))
        <span class="ot">self</span>.b = <span class="dv">0</span>
        <span class="ot">self</span>.eCache = mat(zeros((<span class="ot">self</span>.m,<span class="dv">2</span>))) <span class="co">#first column is valid flag</span>
        <span class="ot">self</span>.K = mat(zeros((<span class="ot">self</span>.m,<span class="ot">self</span>.m)))
        <span class="kw">for</span> i in <span class="dt">range</span>(<span class="ot">self</span>.m):
            <span class="ot">self</span>.K[:,i] = kernelTrans(<span class="ot">self</span>.X, <span class="ot">self</span>.X[i,:], kTup)

<span class="kw">def</span> calcEk(oS, k):
    fXk = <span class="dt">float</span>(multiply(oS.alphas,oS.labelMat).T*oS.K[:,k] + oS.b)
    Ek = fXk - <span class="dt">float</span>(oS.labelMat[k])
    <span class="kw">return</span> Ek

<span class="kw">def</span> selectJ(i, oS, Ei):         <span class="co">#this is the second choice -heurstic, and calcs Ej</span>
    maxK = -<span class="dv">1</span>; maxDeltaE = <span class="dv">0</span>; Ej = <span class="dv">0</span>
    oS.eCache[i] = [<span class="dv">1</span>,Ei]  <span class="co">#set valid #choose the alpha that gives the maximum delta E</span>
    validEcacheList = nonzero(oS.eCache[:,<span class="dv">0</span>].A)[<span class="dv">0</span>]
    <span class="kw">if</span> (<span class="dt">len</span>(validEcacheList)) &gt; <span class="dv">1</span>:
        <span class="kw">for</span> k in validEcacheList:   <span class="co">#loop through valid Ecache values and find the one that maximizes delta E</span>
            <span class="kw">if</span> k == i: <span class="kw">continue</span> <span class="co">#don&#39;t calc for i, waste of time</span>
            Ek = calcEk(oS, k)
            deltaE = <span class="dt">abs</span>(Ei - Ek)
            <span class="kw">if</span> (deltaE &gt; maxDeltaE):
                maxK = k; maxDeltaE = deltaE; Ej = Ek
        <span class="kw">return</span> maxK, Ej
    <span class="kw">else</span>:   <span class="co">#in this case (first time around) we don&#39;t have any valid eCache values</span>
        j = selectJrand(i, oS.m)
        Ej = calcEk(oS, j)
    <span class="kw">return</span> j, Ej

<span class="kw">def</span> updateEk(oS, k):<span class="co">#after any alpha has changed update the new value in the cache</span>
    Ek = calcEk(oS, k)
    oS.eCache[k] = [<span class="dv">1</span>,Ek]

<span class="kw">def</span> innerL(i, oS):
    Ei = calcEk(oS, i)
    <span class="kw">if</span> ((oS.labelMat[i]*Ei &lt; -oS.tol) and (oS.alphas[i] &lt; oS.C)) or ((oS.labelMat[i]*Ei &gt; oS.tol) and (oS.alphas[i] &gt; <span class="dv">0</span>)):
        j,Ej = selectJ(i, oS, Ei) <span class="co">#this has been changed from selectJrand</span>
        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy();
        <span class="kw">if</span> (oS.labelMat[i] != oS.labelMat[j]):
            L = <span class="dt">max</span>(<span class="dv">0</span>, oS.alphas[j] - oS.alphas[i])
            H = <span class="dt">min</span>(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])
        <span class="kw">else</span>:
            L = <span class="dt">max</span>(<span class="dv">0</span>, oS.alphas[j] + oS.alphas[i] - oS.C)
            H = <span class="dt">min</span>(oS.C, oS.alphas[j] + oS.alphas[i])
        <span class="kw">if</span> L==H: <span class="dt">print</span> <span class="st">&quot;L==H&quot;</span>; <span class="kw">return</span> <span class="dv">0</span>
        eta = <span class="fl">2.0</span> * oS.K[i,j] - oS.K[i,i] - oS.K[j,j] <span class="co">#changed for kernel</span>
        <span class="kw">if</span> eta &gt;= <span class="dv">0</span>: <span class="dt">print</span> <span class="st">&quot;eta&gt;=0&quot;</span>; <span class="kw">return</span> <span class="dv">0</span>
        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta
        oS.alphas[j] = clipAlpha(oS.alphas[j],H,L)
        updateEk(oS, j) <span class="co">#added this for the Ecache</span>
        <span class="kw">if</span> (<span class="dt">abs</span>(oS.alphas[j] - alphaJold) &lt; <span class="fl">0.00001</span>): <span class="dt">print</span> <span class="st">&quot;j not moving enough&quot;</span>; <span class="kw">return</span> <span class="dv">0</span>
        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])<span class="co">#update i by the same amount as j</span>
        updateEk(oS, i) <span class="co">#added this for the Ecache                    #the update is in the oppostie direction</span>
        b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i,i] - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[i,j]
        b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.K[i,j]- oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.K[j,j]
        <span class="kw">if</span> (<span class="dv">0</span> &lt; oS.alphas[i]) and (oS.C &gt; oS.alphas[i]): oS.b = b1
        <span class="kw">elif</span> (<span class="dv">0</span> &lt; oS.alphas[j]) and (oS.C &gt; oS.alphas[j]): oS.b = b2
        <span class="kw">else</span>: oS.b = (b1 + b2)/<span class="fl">2.0</span>
        <span class="kw">return</span> <span class="dv">1</span>
    <span class="kw">else</span>: <span class="kw">return</span> <span class="dv">0</span>

<span class="kw">def</span> smoP(dataMatIn, classLabels, C, toler, maxIter,kTup=(<span class="st">&#39;lin&#39;</span>, <span class="dv">0</span>)):    <span class="co">#full Platt SMO</span>
    oS = optStruct(mat(dataMatIn),mat(classLabels).transpose(),C,toler, kTup)
    <span class="dt">iter</span> = <span class="dv">0</span>
    entireSet = <span class="ot">True</span>; alphaPairsChanged = <span class="dv">0</span>
    <span class="kw">while</span> (<span class="dt">iter</span> &lt; maxIter) and ((alphaPairsChanged &gt; <span class="dv">0</span>) or (entireSet)):
        alphaPairsChanged = <span class="dv">0</span>
        <span class="kw">if</span> entireSet:   <span class="co">#go over all</span>
            <span class="kw">for</span> i in <span class="dt">range</span>(oS.m):        
                alphaPairsChanged += innerL(i,oS)
                <span class="dt">print</span> <span class="st">&quot;fullSet, iter: </span><span class="ot">%d</span><span class="st"> i:</span><span class="ot">%d</span><span class="st">, pairs changed </span><span class="ot">%d</span><span class="st">&quot;</span> % (<span class="dt">iter</span>,i,alphaPairsChanged)
            <span class="dt">iter</span> += <span class="dv">1</span>
        <span class="kw">else</span>:<span class="co">#go over non-bound (railed) alphas</span>
            nonBoundIs = nonzero((oS.alphas.A &gt; <span class="dv">0</span>) * (oS.alphas.A &lt; C))[<span class="dv">0</span>]
            <span class="kw">for</span> i in nonBoundIs:
                alphaPairsChanged += innerL(i,oS)
                <span class="dt">print</span> <span class="st">&quot;non-bound, iter: </span><span class="ot">%d</span><span class="st"> i:</span><span class="ot">%d</span><span class="st">, pairs changed </span><span class="ot">%d</span><span class="st">&quot;</span> % (<span class="dt">iter</span>,i,alphaPairsChanged)
            <span class="dt">iter</span> += <span class="dv">1</span>
        <span class="kw">if</span> entireSet: entireSet = <span class="ot">False</span> <span class="co">#toggle entire set loop</span>
        <span class="kw">elif</span> (alphaPairsChanged == <span class="dv">0</span>): entireSet = <span class="ot">True</span>  
        <span class="dt">print</span> <span class="st">&quot;iteration number: </span><span class="ot">%d</span><span class="st">&quot;</span> % <span class="dt">iter</span>
    <span class="kw">return</span> oS.b,oS.alphas

<span class="kw">def</span> calcWs(alphas,dataArr,classLabels):
    X = mat(dataArr); labelMat = mat(classLabels).transpose()
    m,n = shape(X)
    w = zeros((n,<span class="dv">1</span>))
    <span class="kw">for</span> i in <span class="dt">range</span>(m):
        w += multiply(alphas[i]*labelMat[i],X[i,:].T)
    <span class="kw">return</span> w

<span class="kw">def</span> testRbf(k1=<span class="fl">1.3</span>):
    dataArr,labelArr = loadDataSet(<span class="st">&#39;testSetRBF.txt&#39;</span>)
    b,alphas = smoP(dataArr, labelArr, <span class="dv">200</span>, <span class="fl">0.0001</span>, <span class="dv">10000</span>, (<span class="st">&#39;rbf&#39;</span>, k1)) <span class="co">#C=200 important</span>
    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()
    svInd=nonzero(alphas.A&gt;<span class="dv">0</span>)[<span class="dv">0</span>]
    sVs=datMat[svInd] <span class="co">#get matrix of only support vectors</span>
    labelSV = labelMat[svInd];
    <span class="dt">print</span> <span class="st">&quot;there are </span><span class="ot">%d</span><span class="st"> Support Vectors&quot;</span> % shape(sVs)[<span class="dv">0</span>]
    m,n = shape(datMat)
    errorCount = <span class="dv">0</span>
    <span class="kw">for</span> i in <span class="dt">range</span>(m):
        kernelEval = kernelTrans(sVs,datMat[i,:],(<span class="st">&#39;rbf&#39;</span>, k1))
        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b
        <span class="kw">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="dv">1</span>
    <span class="dt">print</span> <span class="st">&quot;the training error rate is: </span><span class="ot">%f</span><span class="st">&quot;</span> % (<span class="dt">float</span>(errorCount)/m)
    dataArr,labelArr = loadDataSet(<span class="st">&#39;testSetRBF2.txt&#39;</span>)
    errorCount = <span class="dv">0</span>
    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()
    m,n = shape(datMat)
    <span class="kw">for</span> i in <span class="dt">range</span>(m):
        kernelEval = kernelTrans(sVs,datMat[i,:],(<span class="st">&#39;rbf&#39;</span>, k1))
        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b
        <span class="kw">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="dv">1</span>    
    <span class="dt">print</span> <span class="st">&quot;the test error rate is: </span><span class="ot">%f</span><span class="st">&quot;</span> % (<span class="dt">float</span>(errorCount)/m)    

<span class="kw">def</span> img2vector(filename):
    returnVect = zeros((<span class="dv">1</span>,<span class="dv">1024</span>))
    fr = <span class="dt">open</span>(filename)
    <span class="kw">for</span> i in <span class="dt">range</span>(<span class="dv">32</span>):
        lineStr = fr.readline()
        <span class="kw">for</span> j in <span class="dt">range</span>(<span class="dv">32</span>):
            returnVect[<span class="dv">0</span>,<span class="dv">32</span>*i+j] = <span class="dt">int</span>(lineStr[j])
    <span class="kw">return</span> returnVect

<span class="kw">def</span> loadImages(dirName):
    <span class="ch">from</span> os <span class="ch">import</span> listdir
    hwLabels = []
    trainingFileList = listdir(dirName)           <span class="co">#load the training set</span>
    m = <span class="dt">len</span>(trainingFileList)
    trainingMat = zeros((m,<span class="dv">1024</span>))
    <span class="kw">for</span> i in <span class="dt">range</span>(m):
        fileNameStr = trainingFileList[i]
        fileStr = fileNameStr.split(<span class="st">&#39;.&#39;</span>)[<span class="dv">0</span>]     <span class="co">#take off .txt</span>
        classNumStr = <span class="dt">int</span>(fileStr.split(<span class="st">&#39;_&#39;</span>)[<span class="dv">0</span>])
        <span class="kw">if</span> classNumStr == <span class="dv">9</span>: hwLabels.append(-<span class="dv">1</span>)
        <span class="kw">else</span>: hwLabels.append(<span class="dv">1</span>)
        trainingMat[i,:] = img2vector(<span class="st">&#39;</span><span class="ot">%s</span><span class="st">/</span><span class="ot">%s</span><span class="st">&#39;</span> % (dirName, fileNameStr))
    <span class="kw">return</span> trainingMat, hwLabels    

<span class="kw">def</span> testDigits(kTup=(<span class="st">&#39;rbf&#39;</span>, <span class="dv">10</span>)):
    dataArr,labelArr = loadImages(<span class="st">&#39;trainingDigits&#39;</span>)
    b,alphas = smoP(dataArr, labelArr, <span class="dv">200</span>, <span class="fl">0.0001</span>, <span class="dv">10000</span>, kTup)
    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()
    svInd=nonzero(alphas.A&gt;<span class="dv">0</span>)[<span class="dv">0</span>]
    sVs=datMat[svInd]
    labelSV = labelMat[svInd];
    <span class="dt">print</span> <span class="st">&quot;there are </span><span class="ot">%d</span><span class="st"> Support Vectors&quot;</span> % shape(sVs)[<span class="dv">0</span>]
    m,n = shape(datMat)
    errorCount = <span class="dv">0</span>
    <span class="kw">for</span> i in <span class="dt">range</span>(m):
        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)
        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b
        <span class="kw">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="dv">1</span>
    <span class="dt">print</span> <span class="st">&quot;the training error rate is: </span><span class="ot">%f</span><span class="st">&quot;</span> % (<span class="dt">float</span>(errorCount)/m)
    dataArr,labelArr = loadImages(<span class="st">&#39;testDigits&#39;</span>)
    errorCount = <span class="dv">0</span>
    datMat=mat(dataArr); labelMat = mat(labelArr).transpose()
    m,n = shape(datMat)
    <span class="kw">for</span> i in <span class="dt">range</span>(m):
        kernelEval = kernelTrans(sVs,datMat[i,:],kTup)
        predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b
        <span class="kw">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="dv">1</span>    
    <span class="dt">print</span> <span class="st">&quot;the test error rate is: </span><span class="ot">%f</span><span class="st">&quot;</span> % (<span class="dt">float</span>(errorCount)/m)


<span class="co">&#39;&#39;&#39;#######********************************</span>
<span class="co">Non-Kernel VErsions below</span>
<span class="co">&#39;&#39;&#39;#######********************************</span>

<span class="kw">class</span> optStructK:
    <span class="kw">def</span> <span class="ot">__init__</span>(<span class="ot">self</span>,dataMatIn, classLabels, C, toler):  <span class="co"># Initialize the structure with the parameters</span>
        <span class="ot">self</span>.X = dataMatIn
        <span class="ot">self</span>.labelMat = classLabels
        <span class="ot">self</span>.C = C
        <span class="ot">self</span>.tol = toler
        <span class="ot">self</span>.m = shape(dataMatIn)[<span class="dv">0</span>]
        <span class="ot">self</span>.alphas = mat(zeros((<span class="ot">self</span>.m,<span class="dv">1</span>)))
        <span class="ot">self</span>.b = <span class="dv">0</span>
        <span class="ot">self</span>.eCache = mat(zeros((<span class="ot">self</span>.m,<span class="dv">2</span>))) <span class="co">#first column is valid flag</span>

<span class="kw">def</span> calcEkK(oS, k):
    fXk = <span class="dt">float</span>(multiply(oS.alphas,oS.labelMat).T*(oS.X*oS.X[k,:].T)) + oS.b
    Ek = fXk - <span class="dt">float</span>(oS.labelMat[k])
    <span class="kw">return</span> Ek

<span class="kw">def</span> selectJK(i, oS, Ei):         <span class="co">#this is the second choice -heurstic, and calcs Ej</span>
    maxK = -<span class="dv">1</span>; maxDeltaE = <span class="dv">0</span>; Ej = <span class="dv">0</span>
    oS.eCache[i] = [<span class="dv">1</span>,Ei]  <span class="co">#set valid #choose the alpha that gives the maximum delta E</span>
    validEcacheList = nonzero(oS.eCache[:,<span class="dv">0</span>].A)[<span class="dv">0</span>]
    <span class="kw">if</span> (<span class="dt">len</span>(validEcacheList)) &gt; <span class="dv">1</span>:
        <span class="kw">for</span> k in validEcacheList:   <span class="co">#loop through valid Ecache values and find the one that maximizes delta E</span>
            <span class="kw">if</span> k == i: <span class="kw">continue</span> <span class="co">#don&#39;t calc for i, waste of time</span>
            Ek = calcEk(oS, k)
            deltaE = <span class="dt">abs</span>(Ei - Ek)
            <span class="kw">if</span> (deltaE &gt; maxDeltaE):
                maxK = k; maxDeltaE = deltaE; Ej = Ek
        <span class="kw">return</span> maxK, Ej
    <span class="kw">else</span>:   <span class="co">#in this case (first time around) we don&#39;t have any valid eCache values</span>
        j = selectJrand(i, oS.m)
        Ej = calcEk(oS, j)
    <span class="kw">return</span> j, Ej

<span class="kw">def</span> updateEkK(oS, k):<span class="co">#after any alpha has changed update the new value in the cache</span>
    Ek = calcEk(oS, k)
    oS.eCache[k] = [<span class="dv">1</span>,Ek]

<span class="kw">def</span> innerLK(i, oS):
    Ei = calcEk(oS, i)
    <span class="kw">if</span> ((oS.labelMat[i]*Ei &lt; -oS.tol) and (oS.alphas[i] &lt; oS.C)) or ((oS.labelMat[i]*Ei &gt; oS.tol) and (oS.alphas[i] &gt; <span class="dv">0</span>)):
        j,Ej = selectJ(i, oS, Ei) <span class="co">#this has been changed from selectJrand</span>
        alphaIold = oS.alphas[i].copy(); alphaJold = oS.alphas[j].copy();
        <span class="kw">if</span> (oS.labelMat[i] != oS.labelMat[j]):
            L = <span class="dt">max</span>(<span class="dv">0</span>, oS.alphas[j] - oS.alphas[i])
            H = <span class="dt">min</span>(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])
        <span class="kw">else</span>:
            L = <span class="dt">max</span>(<span class="dv">0</span>, oS.alphas[j] + oS.alphas[i] - oS.C)
            H = <span class="dt">min</span>(oS.C, oS.alphas[j] + oS.alphas[i])
        <span class="kw">if</span> L==H: <span class="dt">print</span> <span class="st">&quot;L==H&quot;</span>; <span class="kw">return</span> <span class="dv">0</span>
        eta = <span class="fl">2.0</span> * oS.X[i,:]*oS.X[j,:].T - oS.X[i,:]*oS.X[i,:].T - oS.X[j,:]*oS.X[j,:].T
        <span class="kw">if</span> eta &gt;= <span class="dv">0</span>: <span class="dt">print</span> <span class="st">&quot;eta&gt;=0&quot;</span>; <span class="kw">return</span> <span class="dv">0</span>
        oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta
        oS.alphas[j] = clipAlpha(oS.alphas[j],H,L)
        updateEk(oS, j) <span class="co">#added this for the Ecache</span>
        <span class="kw">if</span> (<span class="dt">abs</span>(oS.alphas[j] - alphaJold) &lt; <span class="fl">0.00001</span>): <span class="dt">print</span> <span class="st">&quot;j not moving enough&quot;</span>; <span class="kw">return</span> <span class="dv">0</span>
        oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold - oS.alphas[j])<span class="co">#update i by the same amount as j</span>
        updateEk(oS, i) <span class="co">#added this for the Ecache                    #the update is in the oppostie direction</span>
        b1 = oS.b - Ei- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[i,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[i,:]*oS.X[j,:].T
        b2 = oS.b - Ej- oS.labelMat[i]*(oS.alphas[i]-alphaIold)*oS.X[i,:]*oS.X[j,:].T - oS.labelMat[j]*(oS.alphas[j]-alphaJold)*oS.X[j,:]*oS.X[j,:].T
        <span class="kw">if</span> (<span class="dv">0</span> &lt; oS.alphas[i]) and (oS.C &gt; oS.alphas[i]): oS.b = b1
        <span class="kw">elif</span> (<span class="dv">0</span> &lt; oS.alphas[j]) and (oS.C &gt; oS.alphas[j]): oS.b = b2
        <span class="kw">else</span>: oS.b = (b1 + b2)/<span class="fl">2.0</span>
        <span class="kw">return</span> <span class="dv">1</span>
    <span class="kw">else</span>: <span class="kw">return</span> <span class="dv">0</span>

<span class="kw">def</span> smoPK(dataMatIn, classLabels, C, toler, maxIter):    <span class="co">#full Platt SMO</span>
    oS = optStruct(mat(dataMatIn),mat(classLabels).transpose(),C,toler)
    <span class="dt">iter</span> = <span class="dv">0</span>
    entireSet = <span class="ot">True</span>; alphaPairsChanged = <span class="dv">0</span>
    <span class="kw">while</span> (<span class="dt">iter</span> &lt; maxIter) and ((alphaPairsChanged &gt; <span class="dv">0</span>) or (entireSet)):
        alphaPairsChanged = <span class="dv">0</span>
        <span class="kw">if</span> entireSet:   <span class="co">#go over all</span>
            <span class="kw">for</span> i in <span class="dt">range</span>(oS.m):        
                alphaPairsChanged += innerL(i,oS)
                <span class="dt">print</span> <span class="st">&quot;fullSet, iter: </span><span class="ot">%d</span><span class="st"> i:</span><span class="ot">%d</span><span class="st">, pairs changed </span><span class="ot">%d</span><span class="st">&quot;</span> % (<span class="dt">iter</span>,i,alphaPairsChanged)
            <span class="dt">iter</span> += <span class="dv">1</span>
        <span class="kw">else</span>:<span class="co">#go over non-bound (railed) alphas</span>
            nonBoundIs = nonzero((oS.alphas.A &gt; <span class="dv">0</span>) * (oS.alphas.A &lt; C))[<span class="dv">0</span>]
            <span class="kw">for</span> i in nonBoundIs:
                alphaPairsChanged += innerL(i,oS)
                <span class="dt">print</span> <span class="st">&quot;non-bound, iter: </span><span class="ot">%d</span><span class="st"> i:</span><span class="ot">%d</span><span class="st">, pairs changed </span><span class="ot">%d</span><span class="st">&quot;</span> % (<span class="dt">iter</span>,i,alphaPairsChanged)
            <span class="dt">iter</span> += <span class="dv">1</span>
        <span class="kw">if</span> entireSet: entireSet = <span class="ot">False</span> <span class="co">#toggle entire set loop</span>
        <span class="kw">elif</span> (alphaPairsChanged == <span class="dv">0</span>): entireSet = <span class="ot">True</span>  
        <span class="dt">print</span> <span class="st">&quot;iteration number: </span><span class="ot">%d</span><span class="st">&quot;</span> % <span class="dt">iter</span>
    <span class="kw">return</span> oS.b,oS.alphas</code></pre>
</body>
</html>
